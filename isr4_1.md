### Virtualenv
Virtualenv — это утилита, которая позволяет создавать изолированные виртуальные окружения для Python. По сути, она создаёт внутри вашего проекта каталог, в который кладёт нужную вам версию Python и туда же устанавливает все необходимые пакеты, которые вы будете использовать в своём приложении, фреймворке, скрипте. В результате вы получаете полностью рабочее, изолированное и, что очень важно в дальнейшем, переносимое окружение.

##### Этапы работы с virtualenv:

+ Установка virtualenv
+ Создание окружения
+ Активация окружения
+ Перенос окружения
+ Деактивация окружения

##### Установка virtualenv
```
pip install virtualenv
```

Для проверки использовать команду: ```virtualenv --version```

##### Создание окружения
Необходимо перейти в папку, в которой будет использоваться виртуальное окружение. Для создания окружения в папке используем, например, команду: ```virtualenv venv --python=python3.8```

“venv” в данном случае — это название директории, в которой будет развёрнуто ваше виртуальное окружение, по сути его имя. Может быть любым другим, но, если честно, ни разу не встречал, чтобы кто-то писал что-то кроме venv. Возможно, разные имена имеют смысл, если у вас одновременно десяток проектов и нужно избежать путаницы. Часть после “venv” вообще можно опустить. В этом случае виртуальное окружение установится с той версией, которая задана у вас в системе по умолчанию.

##### Активация окружения
Окружение создано. Теперь чтобы его использовать мы должны выполнить активацию. Это значит, что мы “переключаем контекст” выполнения команд связанных с python на виртуальное окружение. Если проще, то после активации, выполняя любой python скрипт, мы будем использовать python и установленные пакеты не из системы, а из нашего виртуального окружения.

Выполним следующее: ```source venv/bin/activate```

Как только вы это сделаете, перед строкой приглашения вашей консоли появится “(venv)”.

Это значит, что контекст переключен и теперь мы используем виртуальное окружение!

##### Перенос окружения
Для начала делаем “слепок” списка пакетов с их версиями:
```
pip freeze > requirements.txt
```
где

```pip freeze``` — команда, которая выводит список всех установленных пакетов с их версиями

```>``` — символ перенаправления вывода requirements.txt — имя файла, куда мы складываем список пакетов из pip freeze; можно назвать иначе, но так принято ) Файл “requirements.txt” можно и нужно хранить в корне вашего проекта (прямо в директории my_project) и отдавать его в продакшн вместе с кодом. Это хороший тон. А вот класть в репозиторий папку с вашим виртуальным окружением — моветон и “так уже не носят”. Чтобы избежать этого, можете использовать файл .gitignore.

Итак, вы скачали файл requirements.txt вместе с вашим репозиторием на новую машину, и теперь вам нужно развернуть точно такое же окружение, какое было у вас на рабочей системе. Для этого вы по очереди выполняете команды из этого мануала, чтобы создать виртуальное окружение:

```pip install virtualenv

cd <путь_к_репозиторию> 

virtualenv venv --python=<ваша_версия_python> 

source venv/bin/activate
```
и теперь устанавливаете необходимые вам пакеты, используя requirements.txt:
```
pip install -r requirements.txt
```
##### Деактивация окружения
Последний и самый простой этап работы с virtualenv. Чтобы покинуть контекст вашего виртуального окружения и вернуться в систему, вам нужно выполнить
```
deactivate
```
### Pipfile
Pipfile предназначен для замены requirements.txt. Pipenv в настоящее время является эталонной реализацией использования Pipfile. Возможно когда то, сам pip сможет обработать эти файлы. Также стоит отметить, что Pipenv является официальным инструментом управления пакетами, рекомендованным самими разработчиками Python.

Синтаксис Pipfile – это TOML, где файл разделяется на разделы. [dev-packages] для пакетов только для разработки, [packages] для минимально необходимых пакетов и [requires] для других требований, таких как конкретная версия Python и т.п.

Рассмотрим пример файла:

[[source]]
url = "https://pypi.python.org/simple"
verify_ssl = true
name = "pypi"

[dev-packages]
pytest = "*"

[packages]
flask = "==0.12.1"
numpy = "*"
requests = {git = "https://github.com/requests/requests.git", editable = true}

[requires]
python_version = "3.6"
В идеале в Pipfile не должно быть никаких суб-зависимостей. Под этим я подразумеваю, что вы должны включать только те пакеты, которые вы на самом деле импортируете и используете. Нет необходимости хранить chardet в вашем Pipfile только потому, что он является зависимостью requests. (Pipenv должен устанавливать его автоматически.) Pipfile должен хранить только зависимости верхнего уровня, необходимые для вашего проекта.

Pyenv
Pyenv - это простой, мощный и кроссплатформенный инструмент для управления несколькими версиями Python в Linux-системах, он используется для:

переключения глобальной версии Python для каждого пользователя;
установки локальной версии Python для каждого проекта;
управления виртуальными средами, созданными anaconda или virtualenv;
переопределения версии Python с переменной окружения;
поиска команд из нескольких версий Python и для многого другого.
Как правило, версия Python по умолчанию используется для запуска всех ваших приложений, если вы явно не укажете версию, которую хотите использовать в приложении. Но pyenv реализует простую концепцию использования прокладок (легкие исполняемые файлы), чтобы передать вашу команду правильной версии Python, которую вы хотите использовать, когда у вас установлено несколько версий.

Эти прокладки вставлены pyenv в каталоги перед вашим PATH. Поэтому, когда вы запускаете команду Python, она перехватывается соответствующей прокладкой и передается в pyenv, который затем задает версию Python, указанную вашим приложением, и передает ваши команды правильной версии Python.

Pipenv
Pipenv – это набирающий популярность пакет управления виртуальным окружением для Python, который решает некоторые распространенные проблемы, связанные с типичным рабочим процессом, в котором используется pip, virtualenv и старый добрый файл requirements.txt.

Как написано на официальном сайте: Pipenv – это инструмент, который призван привнести в мир Python лучшее из всех упаковочных миров (bundler, composer, npm, cargo, yarn и т. д.).

Помимо решения некоторых распространенных проблем, он стандартизицирует и упрощает процесс разработки с помощью единого инструмента командной строки.

Установка:

pip install pipenv

После этого можно фактически забыть о pip, поскольку Pipenv по сути выступает в качестве его замены. В нем также представлены два новых файла: Pipfile (который предназначен для замены requirements.txt) и Pipfile.lock (который отвечает за детерминированность сборки).

Pipenv использует pip и virtualenv под капотом, что упрощает их использование с помощью одного интерфейса командной строки.

Venv
Этот модуль появился в Python3 и не может быть использован для решения задачи изоляции в Python2. По своему функционалу очень похож на virtualenv.

Основное отличие venv в том, что он встроен в интерпретатор и может отрабатывать ещё до загрузки системных модулей. Для этого, при определении базовой директории с библиотеками, используется примерно такой алгоритм:

в директории с интерпретатором или уровнем выше ищется файл с именем pyvenv.cfg;
если файл найден, в нём ищется ключ home, значение которого и будет базовой директорией;
в базовой директории идёт поиск системной библиотеки (по спец. маркеру os.py);
если что-то пошло не так – всё откатывается к захардкоженному в бинарнике значению.
Вот и вся суть venv, всё остальное уже обёртка над этим.

requirements.txt
Все требования в одном месте
Обычно для запуска проекта требуется несколько внешних пакетов.

Чтобы каждый раз с болью в сердце не собирать их, список этих пакетов принято поставлять вместе с исходным кодом. Принято селить весь список необходимых пакетов в файле requirements.txt в корне проекта. Формат этого файла простой: по одному пакету на строку.

Заморозка пакетов
У одного пакета обычно много версий. Когда мы просим пип установить пакет, он устанавливает самую свежую из доступных.

Это может привести к проблемам: скажем, проект разрабатывался на версии 1.2. Через полгода потребовалось развернуть его заново, пип установил последнюю версию – 1.5. Эта версия может быть не совместима со старой, тогда код сломается.

Например, такая история была с модулем vk: в версии 1.5 нужно было использовать класс vk.api.APISession, а в версии 2.0 – vk.OAuthAPI. Понятное дело, программа, которая использует не ту версию модуля, ломалась – старого класса-то нет.

Чтобы такого не происходило, пакеты принято замораживать – указывать версию пакета вместе с названием. Пип поддерживает такой синтаксис: модуль==версия.

Вот часть requirements.txt из Девмана:

django==1.10.2
pillow==3.3.0
gunicorn==19.6.0
sorl-thumbnail==12.3
ptpython==0.35
Получить все версии пакетов, установленных на вашем компьютере, можно командой pip freeze:

pip freeze
django==1.10.2
pillow==3.3.0
gunicorn==19.6.0
sorl-thumbnail==12.3
ptpython==0.35
...
Все зависимости заморозить и в requirements.txt

Установка
Все пакеты из requirements.txt можно установить одним махом, пип такое умеет: pip install -r requirements.txt.

Зависимости зависимостей
К сожалению, правильное заполнение requirements.txt не решает все проблемы с зависимостями и версиями.

Дело в том, что у перечисленных в файле зависимостей есть свои зависимости. Например, модуль vk для своей установки требует модуль requests. Пип установит его сам, незаметно для нас.

Проблема в том, что если модуль requests не заморожен в исходниках модуля vk, через полгода всё опять может сломаться: версия vk будет правильная, а requests – нет.

Эта проблема свойственна большим проектам, у которых десятки зависимостей и сотни неявных зависимостей.
